"
I represent a Discord Message Object.
I represent a message sent in a channel within Discord.

See https://discordapp.com/developers/docs/resources/channel#message-object

Field	Type	Description
id	snowflake	id of the message
channel_id	snowflake	id of the channel the message was sent in
author*	user object	the author of this message (not guaranteed to be a valid user, see below)
content	string	contents of the message
timestamp	ISO8601 timestamp	when this message was sent
edited_timestamp	?ISO8601 timestamp	when this message was edited (or null if never)
tts	bool	whether this was a TTS message
mention_everyone	bool	whether this message mentions everyone
mentions	array of user objects	users specifically mentioned in the message
mention_roles	array of role object ids	roles specifically mentioned in this message
attachments	array of attachment objects	any attached files
embeds	array of embed objects	any embedded content
reactions?	array of reaction objects	reactions to the message
nonce?	?snowflake	used for validating a message was sent
pinned	bool	whether this message is pinned
webhook_id?	string	if the message is generated by a webhook, this is the webhook's id
type	int	type of message

The author object follows the structure of the user object, but is only a valid user in the case where the message is generated by a user or bot user. If the message is generated by a webhook, the author object corresponds to the webhook's id, username, and avatar. You can tell if a message is generated by a webhook by checking for the webhook_id on the message object.

Message Types

Type	Value
DEFAULT	0
RECIPIENT_ADD	1
RECIPIENT_REMOVE	2
CALL	3
CHANNEL_NAME_CHANGE	4
CHANNEL_ICON_CHANGE	5
CHANNEL_PINNED_MESSAGE	6
GUILD_MEMBER_JOIN	7

"
Class {
	#name : 'DSMessage',
	#superclass : 'DSObject',
	#instVars : [
		'restApi',
		'id',
		'channelId',
		'author',
		'content',
		'timestamp',
		'editedTimestamp',
		'isTextToSpeech',
		'hasMentionEveryone',
		'mentions',
		'attachments',
		'embeds',
		'reactions',
		'nonce',
		'webhookId',
		'type',
		'mentionRoleIds',
		'isPinnedInChannel'
	],
	#category : 'Discord-Core-Model',
	#package : 'Discord-Core',
	#tag : 'Model'
}

{ #category : 'examples' }
DSMessage class >> content [
	<gtExample>
	^ self empty 
		content: 'Hello! I am a basic message content in [Pharo](http://pharo.org).';
		yourself
]

{ #category : 'defaults' }
DSMessage class >> defaultCollection [
	^ DSMessages new
]

{ #category : 'examples' }
DSMessage class >> embedAll [
	<gtExample>
	^ self empty
		embeds: (Array with: DSEmbed all);
		yourself
]

{ #category : 'examples' }
DSMessage class >> embedDescription [
	<gtExample>
	^ self empty
		embeds: (Array with: DSEmbed description);
		yourself
]

{ #category : 'examples' }
DSMessage class >> embedScreenshot [
	<gtExample>
	^ self empty
		embeds: (Array with: DSEmbed screenshot);
		yourself
]

{ #category : 'examples' }
DSMessage class >> empty [
	<gtExample>
	^ self new
		author: DSUser alice;
		timestamp: '2017-09-05T16:09:15.123000+00:00';
		id: '354548251722081425';
		yourself
]

{ #category : 'accessing' }
DSMessage >> attachments [
	^ attachments ifNil: [ attachments := OrderedCollection new ]
]

{ #category : 'accessing' }
DSMessage >> attachments: anObject [
	attachments := anObject
]

{ #category : 'accessing' }
DSMessage >> author [
	^ author
]

{ #category : 'accessing' }
DSMessage >> author: anObject [
	author := anObject
]

{ #category : 'accessing - convenience' }
DSMessage >> authorName [
	"Return author name"
	<return: #String>
	^ self author ifNotNil: #username ifNil: DSConstants emptyAuthorName
]

{ #category : 'accessing' }
DSMessage >> channelId [
	^ channelId
]

{ #category : 'accessing' }
DSMessage >> channelId: anObject [
	channelId := anObject
]

{ #category : 'accessing' }
DSMessage >> content [
	^ content
]

{ #category : 'accessing' }
DSMessage >> content: string [
	"Set the contents of the message."
	string size > DSConstants maxMessageLenght 
		ifTrue: [ DSLongMessageError new
			content: string;
			signal: 'Message ', string size asString, ' long, max. is ', DSConstants maxMessageLenght asString ].
	content := string

]

{ #category : 'accessing' }
DSMessage >> editedTimestamp [
	^ editedTimestamp
]

{ #category : 'accessing' }
DSMessage >> editedTimestamp: anObject [
	editedTimestamp := anObject
]

{ #category : 'enumerating' }
DSMessage >> embedImages [
	"Return all embed images."
	^ self embeds 
		select: #hasImage 
		thenCollect: [ :embed | embed image ]
]

{ #category : 'accessing' }
DSMessage >> embeds [
	^ embeds ifNil: [ embeds := OrderedCollection new ]
]

{ #category : 'accessing' }
DSMessage >> embeds: anObject [
	embeds := anObject
]

{ #category : 'testing' }
DSMessage >> hasAttachments [
	"Return true if the message includes attachments."
	^ self attachments isEmptyOrNil not 
]

{ #category : 'testing' }
DSMessage >> hasContent [
	"Return true if the message has a content."
	^ self content notNil
]

{ #category : 'testing' }
DSMessage >> hasEmbedImages [
	"Return true if any embed object has an image."
	^ self embeds anySatisfy: #hasImage
]

{ #category : 'testing' }
DSMessage >> hasEmbeds [
	"Return true if the message includes embeds."
	^ self embeds isEmptyOrNil not 
]

{ #category : 'testing' }
DSMessage >> hasFuelAttachments [
	"Return true, if any attachment holds a FUEL data.
	FUEL data are serialized Pharo objects. See FLSerializer."
	^ self hasAttachments and: [ self attachments anySatisfy: [ :eachAttachment |
			eachAttachment isFuel ] ]
]

{ #category : 'testing' }
DSMessage >> hasImageAttachments [
	"Return true if any attachment is an image."
	^ self attachments anySatisfy: #isImage
]

{ #category : 'accessing' }
DSMessage >> hasMentionEveryone [
	^ hasMentionEveryone
]

{ #category : 'accessing' }
DSMessage >> hasMentionEveryone: anObject [
	hasMentionEveryone := anObject
]

{ #category : 'accessing' }
DSMessage >> id [
	^ id
]

{ #category : 'accessing' }
DSMessage >> id: anObject [
	id := anObject
]

{ #category : 'enumerating' }
DSMessage >> imageAttachments [
	"Return attachments with images."
	^ self attachments select: #isImage
]

{ #category : 'testing' }
DSMessage >> isMessage [
	^ true
]

{ #category : 'accessing' }
DSMessage >> isPinnedInChannel [
	^ isPinnedInChannel
]

{ #category : 'accessing' }
DSMessage >> isPinnedInChannel: anObject [
	isPinnedInChannel := anObject
]

{ #category : 'accessing' }
DSMessage >> isTextToSpeech [
	^ isTextToSpeech
]

{ #category : 'accessing' }
DSMessage >> isTextToSpeech: anObject [
	isTextToSpeech := anObject
]

{ #category : 'public' }
DSMessage >> materialize [
	"Materialize the attachment data. 
	It is supposed that #data return a ByteArray object."
	^ (self attachments detect: #isFuel ifNone: nil) ifNotNil: #materialize
]

{ #category : 'accessing' }
DSMessage >> mentionRoleIds [
	^ mentionRoleIds
]

{ #category : 'accessing' }
DSMessage >> mentionRoleIds: anObject [
	mentionRoleIds := anObject
]

{ #category : 'accessing' }
DSMessage >> mentions [
	^ mentions
]

{ #category : 'accessing' }
DSMessage >> mentions: anObject [
	mentions := anObject
]

{ #category : 'accessing' }
DSMessage >> nonce [
	^ nonce
]

{ #category : 'accessing' }
DSMessage >> nonce: anObject [
	nonce := anObject
]

{ #category : 'convenience' }
DSMessage >> numberOfAttachments [
	^ self attachments ifNotNil: #size ifNil: 0
]

{ #category : 'convenience' }
DSMessage >> numberOfEmbeds [
	^ self embeds ifNotNil: #size ifNil: 0
]

{ #category : 'printing' }
DSMessage >> printFullMessage [
	^ Text streamContents: [ :aStream | 
		self printFullMessageOn: aStream ]
]

{ #category : 'printing' }
DSMessage >> printFullMessageOn: aStream [
	self content ifNotNil: [ :string | aStream << string << String crlfcrlf ].
	self embeds do: [ :eachEmbed |
		eachEmbed printFullMessageOn: aStream ].
	self attachments ifNotNil: [ :collection | 
		collection 
			do: [ :eachAttachment | aStream print: eachAttachment ]
			separatedBy: [ aStream crlf. ] ]
]

{ #category : 'accessing' }
DSMessage >> reactions [
	^ reactions
]

{ #category : 'accessing' }
DSMessage >> reactions: anObject [
	reactions := anObject
]

{ #category : 'accessing' }
DSMessage >> restApi [
	^ restApi
]

{ #category : 'accessing' }
DSMessage >> restApi: aDSRestApi [
	"Set object responsible for Discord REST API communication."
	restApi := aDSRestApi.
]

{ #category : 'accessing' }
DSMessage >> timestamp [
	^ timestamp
]

{ #category : 'accessing' }
DSMessage >> timestamp: anObject [
	timestamp := anObject
]

{ #category : 'accessing' }
DSMessage >> type [
	^ type
]

{ #category : 'accessing' }
DSMessage >> type: anObject [
	type := anObject
]

{ #category : 'accessing - convenience' }
DSMessage >> username [
	"Return author name"
	<return: #String>
	^ self authorName
]

{ #category : 'accessing' }
DSMessage >> webhookId [
	^ webhookId
]

{ #category : 'accessing' }
DSMessage >> webhookId: anObject [
	webhookId := anObject
]
